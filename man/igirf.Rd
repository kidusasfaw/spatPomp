% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/igirf.R
\docType{methods}
\name{igirf}
\alias{igirf}
\alias{igirf-spatPomp}
\alias{igirf,spatPomp-method}
\alias{igirf-igirfd_spatPomp}
\alias{igirf,igirfd_spatPomp-method}
\title{Iterated guided intermediate resampling filter (iGIRF)}
\usage{
\S4method{igirf}{spatPomp}(data, Ngirf, Np, rw.sd, cooling.type,
  cooling.fraction.50, Ninter, lookahead, Nguide, h, theta.to.v,
  v.to.theta, tol = 1e-17, max.fail = Inf, save.states = FALSE, ...,
  verbose = getOption("verbose", FALSE))

\S4method{igirf}{igirfd_spatPomp}(data, Ngirf, Np, rw.sd, cooling.type,
  cooling.fraction.50, Ninter, lookahead, Nguide, h, theta.to.v,
  v.to.theta, tol, ..., verbose = getOption("verbose", FALSE))
}
\arguments{
\item{data}{either a data frame holding the spatiotemporal data,
or an object of class \sQuote{spatPomp},
i.e., the output of another \pkg{spatPomp} calculation.}

\item{Ngirf}{the number of iterations of perturbed GIRF.}

\item{Np}{the number of particles to use in filtering.
This may be specified as a single positive integer, in which case the same number of particles will be used at each timestep.
Alternatively, if one wishes the number of particles to vary across timestep, one may specify \code{Np} either as a vector of positive integers (of length \code{length(time(object))}) or as a function taking a positive integer argument.
In the latter case, \code{Np(n)} must be a single positive integer,
representing the number of particles to be used at the \code{n}-th timestep:
\code{Np(1)} is the number of particles to use going from \code{timezero(object)} to \code{time(object)[1]},
\code{Np(2)}, from \code{time(object)[1]} to \code{time(object)[2]},
and so on.}

\item{rw.sd}{specification of the magnitude of the random-walk perturbations that will be applied to some or all model parameters.
Parameters that are to be estimated should have positive perturbations specified here.
The specification is given using the \code{\link{rw.sd}} function, which creates a list of unevaluated expressions.
The latter are evaluated in a context where the model time variable is defined (as \code{time}).
The expression \code{ivp(s)} can be used in this context as shorthand for \preformatted{ifelse(time==time[1],s,0).}
Likewise, \code{ivp(s,lag)} is equivalent to \preformatted{ifelse(time==time[lag],s,0).}
See below for some examples.

The perturbations that are applied are normally distributed with the specified s.d.
If parameter transformations have been supplied, then the perturbations are applied on the transformed (estimation) scale.}

\item{cooling.type}{specifications for the cooling schedule,
i.e., the manner and rate with which the intensity of the parameter perturbations is reduced with successive filtering iterations.
\code{cooling.type} specifies the nature of the cooling schedule.
See below (under \dQuote{Specifying the perturbations}) for more detail.}

\item{cooling.fraction.50}{specifications for the cooling schedule,
i.e., the manner and rate with which the intensity of the parameter perturbations is reduced with successive filtering iterations.
\code{cooling.type} specifies the nature of the cooling schedule.
See below (under \dQuote{Specifying the perturbations}) for more detail.}

\item{theta.to.v}{A user-provided function taking two named arguments:
\code{meas.mean} (representing the observation mean given a latent state - as computed using the \code{h} function above)
and \code{param.vec} (representing a parameter vector for the model). It should return a scalar approximation
to the variance of the observed value given a latent state and parameter vector.
For more information, see the examples section below.}

\item{v.to.theta}{A user-provided function taking three named arguments:
\code{var} (representing an empirical variance), \code{state.vec} (representing a latent state) and \code{param.vec}
 (representing a parameter vector for the model). The function should return a parameter vector having observation
  noise consistent with variance \code{var} at latent state \code{state.vec} with other parameters given by \code{param.vec}.}

\item{tol}{positive numeric scalar;
particles with likelihood less than \code{tol} are considered to be incompatible with the data.
See the section on \emph{Filtering Failures} for more information.}

\item{max.fail}{integer; the maximum number of filtering failures allowed (see below).
If the number of filtering failures exceeds this number, execution will terminate with an error.
By default, \code{max.fail} is set to infinity, so no error can be triggered.}

\item{...}{additional arguments supply new or modify existing model characteristics or components.
See \code{\link{pomp}} for a full list of recognized arguments.

When named arguments not recognized by \code{\link{pomp}} are provided, these are made available to all basic components via the so-called \dfn{userdata} facility.
This allows the user to pass information to the basic components outside of the usual routes of covariates (\code{covar}) and model parameters (\code{params}).
See \link[=userdata]{?userdata} for information on how to use this facility.}

\item{verbose}{logical; if \code{TRUE}, diagnostic messages will be printed to the console.}
}
\value{
Upon successful completion, \code{igirf} returns an object of class
\sQuote{igirfd.spatPomp}.
}
\description{
An implementation of a parameter estimation algorithm combining
GIRF with IF2, proposed by Park and Ionides (2019), following the pseudocode in Asfaw, Ionides and King (2019).
}
\section{Methods}{

The following methods are available for such an object:
\describe{
\item{\code{\link{coef}}}{ gives the Monte Carlo estimate of the maximum likelihood. }
}
}

\references{
\park2019

\asfaw2019
}
\seealso{
Other particle filter methods: \code{\link{asifir}},
  \code{\link{asif}}, \code{\link{girf}},
  \code{\link{hippie}}

Other \pkg{spatPomp} filtering methods: \code{\link{asifir}},
  \code{\link{asif}}, \code{\link{girf}}
}
\concept{\pkg{spatPomp} filtering methods}
\concept{particle filter methods}
